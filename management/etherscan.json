{"language":"Solidity","sources":{"src/PatchworkProtocol.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n\n    ____        __       __                       __  \n   / __ \\____ _/ /______/ /_ _      ______  _____/ /__\n  / /_/ / __ `/ __/ ___/ __ \\ | /| / / __ \\/ ___/ //_/\n / ____/ /_/ / /_/ /__/ / / / |/ |/ / /_/ / /  / ,<   \n/_/ ___\\__,_/\\__/\\___/_/ /_/|__/|__/\\____/_/  /_/|_|  \n   / __ \\_________  / /_____  _________  / /          \n  / /_/ / ___/ __ \\/ __/ __ \\/ ___/ __ \\/ /           \n / ____/ /  / /_/ / /_/ /_/ / /__/ /_/ / /            \n/_/   /_/   \\____/\\__/\\____/\\___/\\____/_/          \n\n*/\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IPatchwork721.sol\";\nimport \"./interfaces/IPatchworkSingleAssignable.sol\";\nimport \"./interfaces/IPatchworkMultiAssignable.sol\";\nimport \"./interfaces/IPatchworkLiteRef.sol\";\nimport \"./interfaces/IPatchworkPatch.sol\";\nimport \"./interfaces/IPatchwork1155Patch.sol\";\nimport \"./interfaces/IPatchworkAccountPatch.sol\";\nimport \"./interfaces/IPatchworkProtocol.sol\";\nimport \"./interfaces/IPatchworkMintable.sol\";\nimport \"./interfaces/IPatchworkScoped.sol\";\n\n/** \n@title Patchwork Protocol\n@author Runic Labs, Inc\n*/\ncontract PatchworkProtocol is IPatchworkProtocol, Ownable, ReentrancyGuard {\n\n    /// Scopes\n    mapping(string => Scope) private _scopes;\n\n    /**\n    @notice unique references\n    @dev A hash of target + targetTokenId + literef provides uniqueness\n    */\n    mapping(bytes32 => bool) private _liteRefs;\n\n    /**\n    @notice unique patches\n    @dev Hash of the patch mapped to a boolean indicating its uniqueness\n    */\n    mapping(bytes32 => bool) private _uniquePatches;\n\n    /// Balance of the protocol\n    uint256 private _protocolBalance;\n\n    /**\n    @notice protocol bankers\n    @dev Map of addresses authorized to set fees and withdraw funds for the protocol\n    @dev Does not allow for scope balance withdrawl\n    */\n    mapping(address => bool) private _protocolBankers;\n\n    /// Current protocol fee configuration\n    FeeConfig private _protocolFeeConfig;\n\n    /// Proposed protocol fee configuration\n    mapping(string => ProposedFeeConfig) private _proposedFeeConfigs;\n\n    /// scope-based fee overrides\n    mapping(string => FeeConfigOverride) private _scopeFeeOverrides; \n\n    /// Scope name cache\n    mapping(address => string) private _scopeNameCache;\n\n    /// How much time must elapse before a fee change can be committed (1209600 = 2 weeks)\n    uint256 public constant FEE_CHANGE_TIMELOCK = 1209600; \n\n    /// The denominator for fee basis points\n    uint256 private constant _FEE_BASIS_DENOM = 10000;\n\n    /// The maximum basis points patchwork can ever be configured to\n    uint256 private constant _PROTOCOL_FEE_CEILING = 3000;\n\n    /// Constructor\n    /// @param owner_ The address of the initial owner\n    constructor(address owner_) Ownable(owner_) ReentrancyGuard() {}\n\n    /**\n    @dev See {IPatchworkProtocol-claimScope}\n    */\n    function claimScope(string calldata scopeName) public {\n        if (bytes(scopeName).length == 0) {\n            revert NotAuthorized(msg.sender);\n        }\n        Scope storage s = _scopes[scopeName];\n        if (s.owner != address(0)) {\n            revert ScopeExists(scopeName);\n        }\n        s.owner = msg.sender;\n        s.requireWhitelist = true; // better security by default\n        emit ScopeClaim(scopeName, msg.sender);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-transferScopeOwnership}\n    */\n    function transferScopeOwnership(string calldata scopeName, address newOwner) public {\n        Scope storage s = _mustHaveScope(scopeName);\n        _mustBeOwner(s);\n        if (newOwner == address(0)) {\n            revert ScopeTransferNotAllowed(address(0));\n        }\n        s.ownerElect = newOwner;\n        emit ScopeTransferElect(scopeName, s.owner, s.ownerElect);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-cancelScopeTransfer}\n    */\n    function cancelScopeTransfer(string calldata scopeName) public {\n        Scope storage s = _mustHaveScope(scopeName);\n        _mustBeOwner(s);\n        emit ScopeTransferCancel(scopeName, s.owner, s.ownerElect);\n        s.ownerElect = address(0);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-acceptScopeTransfer}\n    */\n    function acceptScopeTransfer(string calldata scopeName) public {\n        Scope storage s = _mustHaveScope(scopeName);\n        if (s.ownerElect == msg.sender) {\n            address oldOwner = s.owner;\n            s.owner = msg.sender;\n            s.ownerElect = address(0);\n            emit ScopeTransfer(scopeName, oldOwner, msg.sender);\n        } else {\n            revert NotAuthorized(msg.sender);\n        }\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-getScopeOwnerElect}\n    */\n    function getScopeOwnerElect(string calldata scopeName) public view returns (address ownerElect) {\n        return _scopes[scopeName].ownerElect;\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-getScopeOwner}\n    */\n    function getScopeOwner(string calldata scopeName) public view returns (address owner) {\n        return _scopes[scopeName].owner;\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-addOperator}\n    */\n    function addOperator(string calldata scopeName, address op) public {\n        Scope storage s = _mustHaveScope(scopeName);\n        _mustBeOwner(s);\n        s.operators[op] = true;\n        emit ScopeAddOperator(scopeName, msg.sender, op);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-removeOperator}\n    */\n    function removeOperator(string calldata scopeName, address op) public {\n        Scope storage s = _mustHaveScope(scopeName);\n        _mustBeOwner(s);\n        s.operators[op] = false;\n        emit ScopeRemoveOperator(scopeName, msg.sender, op);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-setScopeRules}\n    */\n    function setScopeRules(string calldata scopeName, bool allowUserPatch, bool allowUserAssign, bool requireWhitelist) public {\n        Scope storage s = _mustHaveScope(scopeName);\n        _mustBeOwner(s);\n        s.allowUserPatch = allowUserPatch;\n        s.allowUserAssign = allowUserAssign;\n        s.requireWhitelist = requireWhitelist;\n        emit ScopeRuleChange(scopeName, msg.sender, allowUserPatch, allowUserAssign, requireWhitelist);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-setMintConfiguration}\n    */\n    function setMintConfiguration(address addr, MintConfig memory config) public {\n        if (!IERC165(addr).supportsInterface(type(IPatchworkMintable).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        string memory scopeName = _getScopeName(addr);\n        Scope storage scope = _mustHaveScope(scopeName);\n        _mustBeWhitelisted(scopeName, scope, addr);\n        _mustBeOwnerOrOperator(scope);\n        scope.mintConfigurations[addr] = config;\n        emit MintConfigure(scopeName, msg.sender, addr, config);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-getMintConfiguration}\n    */\n    function getMintConfiguration(address addr) public view returns (MintConfig memory config) {\n        if (!IERC165(addr).supportsInterface(type(IPatchworkMintable).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        Scope storage scope = _mustHaveScope(_getScopeNameViewOnly(addr));\n        return scope.mintConfigurations[addr];\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-setPatchFee}\n    */\n    function setPatchFee(address addr, uint256 baseFee) public {\n        if (!IERC165(addr).supportsInterface(type(IPatchworkScoped).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        string memory scopeName = _getScopeName(addr);\n        Scope storage scope = _mustHaveScope(scopeName);\n        _mustBeWhitelisted(scopeName, scope, addr);\n        _mustBeOwnerOrOperator(scope);\n        scope.patchFees[addr] = baseFee;\n        emit PatchFeeChange(scopeName, addr, baseFee);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-getPatchFee}\n    */\n    function getPatchFee(address addr) public view returns (uint256 baseFee) {\n        if (!IERC165(addr).supportsInterface(type(IPatchworkScoped).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        Scope storage scope = _mustHaveScope(_getScopeNameViewOnly(addr));\n        return scope.patchFees[addr];\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-setAssignFee}\n    */\n    function setAssignFee(address fragmentAddress, uint256 baseFee) public {\n        if (!IERC165(fragmentAddress).supportsInterface(type(IPatchworkScoped).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        string memory scopeName = _getScopeName(fragmentAddress);\n        Scope storage scope = _mustHaveScope(scopeName);\n        _mustBeWhitelisted(scopeName, scope, fragmentAddress);\n        _mustBeOwnerOrOperator(scope);\n        scope.assignFees[fragmentAddress] = baseFee;\n        emit AssignFeeChange(scopeName, fragmentAddress, baseFee);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-getAssignFee}\n    */\n    function getAssignFee(address fragmentAddress) public view returns (uint256 baseFee) {\n        if (!IERC165(fragmentAddress).supportsInterface(type(IPatchworkScoped).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        Scope storage scope = _mustHaveScope(_getScopeNameViewOnly(fragmentAddress));\n        return scope.assignFees[fragmentAddress];\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-addBanker}\n    */\n    function addBanker(string memory scopeName, address addr) public {\n        Scope storage scope = _mustHaveScope(scopeName);\n        _mustBeOwnerOrOperator(scope);\n        scope.bankers[addr] = true;\n        emit ScopeBankerAdd(scopeName, msg.sender, addr);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-removeBanker}\n    */\n    function removeBanker(string memory scopeName, address addr) public {\n        Scope storage scope = _mustHaveScope(scopeName);\n        _mustBeOwnerOrOperator(scope);\n        delete scope.bankers[addr];\n        emit ScopeBankerRemove(scopeName, msg.sender, addr);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-withdraw}\n    */\n    function withdraw(string memory scopeName, uint256 amount) public nonReentrant {\n        Scope storage scope = _mustHaveScope(scopeName);\n        if (msg.sender != scope.owner && !scope.bankers[msg.sender]) {\n            revert NotAuthorized(msg.sender);\n        }\n        if (amount > scope.balance) {\n            revert InsufficientFunds();\n        }\n        // modify state before calling to send\n        scope.balance -= amount;\n        // transfer funds\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        if (!sent) {\n            revert FailedToSend();\n        }\n        emit ScopeWithdraw(scopeName, msg.sender, amount);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-balanceOf}\n    */\n    function balanceOf(string memory scopeName) public view returns (uint256 balance) {\n        Scope storage scope = _mustHaveScope(scopeName);\n        return scope.balance;\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-mint}\n    */\n    function mint(address to, address mintable, bytes calldata data) external payable returns (uint256 tokenId) {\n        (MintConfig memory config, string memory scopeName, Scope storage scope) = _setupMint(mintable);\n        if (msg.value != config.flatFee) {\n            revert IncorrectFeeAmount();\n        }\n        _handleMintFee(scopeName, scope);\n        tokenId = IPatchworkMintable(mintable).mint(to, data);\n        emit Mint(msg.sender, scopeName, to, mintable, data);\n    }\n    \n    /**\n    @dev See {IPatchworkProtocol-mintBatch}\n    */\n    function mintBatch(address to, address mintable, bytes calldata data, uint256 quantity) external payable returns (uint256[] memory tokenIds) {\n        (MintConfig memory config, string memory scopeName, Scope storage scope) = _setupMint(mintable);\n        uint256 totalFee = config.flatFee * quantity;\n        if (msg.value != totalFee) {\n            revert IncorrectFeeAmount();\n        }\n        _handleMintFee(scopeName, scope);\n        tokenIds = IPatchworkMintable(mintable).mintBatch(to, data, quantity);\n        emit MintBatch(msg.sender, scopeName, to, mintable, data, quantity);\n    }\n\n    /// Common to mints\n    function _setupMint(address mintable) internal view returns (MintConfig memory config, string memory scopeName, Scope storage scope) {\n        if (!IERC165(mintable).supportsInterface(type(IPatchworkMintable).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        scopeName = _getScopeNameViewOnly(mintable);\n        scope = _mustHaveScope(scopeName);\n        _mustBeWhitelisted(scopeName, scope, mintable);\n        config = scope.mintConfigurations[mintable];\n        if (!config.active) {\n            revert MintNotActive();\n        }\n    }\n\n    /// Common to mints\n    function _handleMintFee(string memory scopeName, Scope storage scope) internal {\n        // Account for 100% of the message value\n        if (msg.value != 0) {\n            uint256 mintBp;\n            FeeConfigOverride storage feeOverride = _scopeFeeOverrides[scopeName];\n            if (feeOverride.active) {\n                mintBp = feeOverride.mintBp;\n            } else {\n                mintBp = _protocolFeeConfig.mintBp;\n            }\n            uint256 protocolFee = msg.value * mintBp / _FEE_BASIS_DENOM;\n            _protocolBalance += protocolFee;\n            scope.balance += msg.value - protocolFee;\n        }\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-proposeProtocolFeeConfig}\n    */\n    function proposeProtocolFeeConfig(FeeConfig memory config) public onlyProtoOwnerBanker {\n        if (config.assignBp > _PROTOCOL_FEE_CEILING || config.mintBp > _PROTOCOL_FEE_CEILING || config.patchBp > _PROTOCOL_FEE_CEILING) {\n            revert InvalidFeeValue();\n        }\n        _proposedFeeConfigs[\"\"] = ProposedFeeConfig(config, block.timestamp, true);\n        emit ProtocolFeeConfigPropose(config);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-commitProtocolFeeConfig}\n    */\n    function commitProtocolFeeConfig() public onlyProtoOwnerBanker {\n        (FeeConfig memory config, /* bool active */) = _preCommitFeeChange(\"\");\n        _protocolFeeConfig = config;\n        emit ProtocolFeeConfigCommit(_protocolFeeConfig);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-getProtocolFeeConfig}\n    */\n    function getProtocolFeeConfig() public view returns (FeeConfig memory config) {\n        return _protocolFeeConfig;\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-proposeScopeFeeOverride}\n    */\n    function proposeScopeFeeOverride(string memory scopeName, FeeConfigOverride memory config) public onlyProtoOwnerBanker {\n        if (config.assignBp > _PROTOCOL_FEE_CEILING || config.mintBp > _PROTOCOL_FEE_CEILING || config.patchBp > _PROTOCOL_FEE_CEILING) {\n            revert InvalidFeeValue();\n        }\n        _proposedFeeConfigs[scopeName] = ProposedFeeConfig(\n            FeeConfig(config.mintBp, config.patchBp, config.assignBp), block.timestamp, config.active);\n        emit ScopeFeeOverridePropose(scopeName, config);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-commitScopeFeeOverride}\n    */\n    function commitScopeFeeOverride(string memory scopeName) public onlyProtoOwnerBanker {\n        (FeeConfig memory config, bool active) = _preCommitFeeChange(scopeName);\n        FeeConfigOverride memory feeOverride = FeeConfigOverride(config.mintBp, config.patchBp, config.assignBp, active);\n        if (!active) {\n            delete _scopeFeeOverrides[scopeName];\n        } else {\n            _scopeFeeOverrides[scopeName] = feeOverride;\n        }\n        emit ScopeFeeOverrideCommit(scopeName, feeOverride);\n    }\n\n    /**\n    @dev commits a fee change if a proposal exists and timelock is satisfied\n    @param scopeName \"\" for protocol or the scope name\n    @return config The proposed config\n    @return active The proposed active state (only applies to fee overrides)\n    */\n    function _preCommitFeeChange(string memory scopeName) private returns (FeeConfig memory config, bool active) {\n        ProposedFeeConfig storage proposal = _proposedFeeConfigs[scopeName];\n        if (proposal.timestamp == 0) {\n            revert NoProposedFeeSet();\n        }\n        if (block.timestamp < proposal.timestamp + FEE_CHANGE_TIMELOCK) {\n            revert TimelockNotElapsed();\n        }\n        config = proposal.config;\n        active = proposal.active;\n        delete _proposedFeeConfigs[scopeName];\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-getScopeFeeOverride}\n    */\n    function getScopeFeeOverride(string memory scopeName) public view returns (FeeConfigOverride memory config) {\n        return _scopeFeeOverrides[scopeName];\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-addProtocolBanker}\n    */\n    function addProtocolBanker(address addr) external onlyOwner {\n        _protocolBankers[addr] = true;\n        emit ProtocolBankerAdd(msg.sender, addr);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-removeProtocolBanker}\n    */\n    function removeProtocolBanker(address addr) external onlyOwner {\n        delete _protocolBankers[addr];\n        emit ProtocolBankerRemove(msg.sender, addr);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-withdrawFromProtocol}\n    */\n    function withdrawFromProtocol(uint256 amount) external nonReentrant onlyProtoOwnerBanker {\n        if (amount > _protocolBalance) {\n            revert InsufficientFunds();\n        }\n        _protocolBalance -= amount;\n         (bool sent,) = msg.sender.call{value: amount}(\"\");\n        if (!sent) {\n            revert FailedToSend();\n        }\n        emit ProtocolWithdraw(msg.sender, amount);\n    }\n\n    function balanceOfProtocol() public view returns (uint256 balance) {\n        return _protocolBalance;\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-addWhitelist}\n    */\n    function addWhitelist(string calldata scopeName, address addr) public {\n        Scope storage s = _mustHaveScope(scopeName);\n        _mustBeOwnerOrOperator(s);\n        s.whitelist[addr] = true;\n        emit ScopeWhitelistAdd(scopeName, msg.sender, addr);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-removeWhitelist}\n    */\n    function removeWhitelist(string calldata scopeName, address addr) public {\n        Scope storage s = _mustHaveScope(scopeName);\n        _mustBeOwnerOrOperator(s);\n        s.whitelist[addr] = false;\n        emit ScopeWhitelistRemove(scopeName, msg.sender, addr);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-patch}\n    */\n    function patch(address owner, address originalAddress, uint originalTokenId, address patchAddress) external payable returns (uint256 tokenId) {\n        if (!IERC165(patchAddress).supportsInterface(type(IPatchworkPatch).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        IPatchworkPatch patch_ = IPatchworkPatch(patchAddress);\n        string memory scopeName = _getScopeName(patchAddress);\n        Scope storage scope = _mustHaveScope(scopeName);\n        _mustBeWhitelisted(scopeName, scope, patchAddress);\n        if (scope.owner == msg.sender || scope.operators[msg.sender]) {\n            // continue\n        } else if (scope.allowUserPatch) {\n            // continue\n        } else {\n            revert NotAuthorized(msg.sender);\n        }\n        _handlePatchFee(scopeName, scope, patchAddress);\n        // limit this to one unique patch (originalAddress+TokenID+patchAddress)\n        bytes32 _hash = keccak256(abi.encodePacked(originalAddress, originalTokenId, patchAddress));\n        if (_uniquePatches[_hash]) {\n            revert AlreadyPatched(originalAddress, originalTokenId, patchAddress);\n        }\n        _uniquePatches[_hash] = true;\n        tokenId = patch_.mintPatch(owner, IPatchworkPatch.PatchTarget(originalAddress, originalTokenId));\n        emit Patch(owner, originalAddress, originalTokenId, patchAddress, tokenId);\n        return tokenId;\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-patchBurned}\n    */\n    function patchBurned(address originalAddress, uint originalTokenId, address patchAddress) external onlyFrom(patchAddress) {\n        bytes32 _hash = keccak256(abi.encodePacked(originalAddress, originalTokenId, patchAddress));\n        delete _uniquePatches[_hash];\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-patch1155}\n    */\n    function patch1155(address to, address originalAddress, uint originalTokenId, address originalAccount, address patchAddress) external payable returns (uint256 tokenId) {\n        if (!IERC165(patchAddress).supportsInterface(type(IPatchwork1155Patch).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        IPatchwork1155Patch patch_ = IPatchwork1155Patch(patchAddress);\n        string memory scopeName = _getScopeName(patchAddress);\n        Scope storage scope = _mustHaveScope(scopeName);\n        _mustBeWhitelisted(scopeName, scope, patchAddress);\n        if (scope.owner == msg.sender || scope.operators[msg.sender]) {\n            // continue\n        } else if (scope.allowUserPatch) {\n            // continue\n        } else {\n            revert NotAuthorized(msg.sender);\n        }\n        _handlePatchFee(scopeName, scope, patchAddress);\n        // limit this to one unique patch (originalAddress+TokenID+patchAddress)\n        bytes32 _hash = keccak256(abi.encodePacked(originalAddress, originalTokenId, originalAccount, patchAddress));\n        if (_uniquePatches[_hash]) {\n            revert ERC1155AlreadyPatched(originalAddress, originalTokenId, originalAccount, patchAddress);\n        }\n        _uniquePatches[_hash] = true;\n        tokenId = patch_.mintPatch(to, IPatchwork1155Patch.PatchTarget(originalAddress, originalTokenId, originalAccount));\n        emit ERC1155Patch(to, originalAddress, originalTokenId, originalAccount, patchAddress, tokenId);\n        return tokenId;\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-patchBurned1155}\n    */\n    function patchBurned1155(address originalAddress, uint originalTokenId, address originalAccount, address patchAddress) external onlyFrom(patchAddress) {\n        bytes32 _hash = keccak256(abi.encodePacked(originalAddress, originalTokenId, originalAccount, patchAddress));\n        delete _uniquePatches[_hash];\n    }\n    \n    /**\n    @dev See {IPatchworkProtocol-patchAccount}\n    */\n    function patchAccount(address owner, address originalAddress, address patchAddress) external payable returns (uint256 tokenId) {\n        if (!IERC165(patchAddress).supportsInterface(type(IPatchworkAccountPatch).interfaceId)) {\n            revert UnsupportedContract();\n        }\n        IPatchworkAccountPatch patch_ = IPatchworkAccountPatch(patchAddress);\n        string memory scopeName = _getScopeName(patchAddress);\n        Scope storage scope = _mustHaveScope(scopeName);\n        _mustBeWhitelisted(scopeName, scope, patchAddress);\n        if (scope.owner == msg.sender || scope.operators[msg.sender]) {\n            // continue\n        } else if (scope.allowUserPatch) { // This allows any user to patch any address\n            // continue\n        } else {\n            revert NotAuthorized(msg.sender);\n        }\n        _handlePatchFee(scopeName, scope, patchAddress);\n        // limit this to one unique patch (originalAddress+patchAddress)\n        bytes32 _hash = keccak256(abi.encodePacked(originalAddress, patchAddress));\n        if (_uniquePatches[_hash]) {\n            revert AccountAlreadyPatched(originalAddress, patchAddress);\n        }\n        _uniquePatches[_hash] = true;\n        tokenId = patch_.mintPatch(owner, originalAddress);\n        emit AccountPatch(owner, originalAddress, patchAddress, tokenId);\n        return tokenId;\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-patchBurnedAccount}\n    */\n    function patchBurnedAccount(address originalAddress, address patchAddress) external onlyFrom(patchAddress) {\n        bytes32 _hash = keccak256(abi.encodePacked(originalAddress, patchAddress));\n        delete _uniquePatches[_hash];\n    }\n\n    /// common to patches\n    function _handlePatchFee(string memory scopeName, Scope storage scope, address patchAddress) private {\n        uint256 patchFee = scope.patchFees[patchAddress];\n        if (msg.value != patchFee) {\n            revert IncorrectFeeAmount();\n        }\n        if (msg.value > 0) {\n            uint256 patchBp;\n            FeeConfigOverride storage feeOverride = _scopeFeeOverrides[scopeName];\n            if (feeOverride.active) {\n                patchBp = feeOverride.patchBp;\n            } else {\n                patchBp = _protocolFeeConfig.patchBp;\n            }\n            uint256 protocolFee = msg.value * patchBp / _FEE_BASIS_DENOM;\n            _protocolBalance += protocolFee;\n            scope.balance += msg.value - protocolFee;\n        }\n    }\n\n    // common to assigns\n    function _handleAssignFee(string memory scopeName, Scope storage scope, address fragmentAddress) private {\n        uint256 assignFee = scope.assignFees[fragmentAddress];\n        if (msg.value != assignFee) {\n            revert IncorrectFeeAmount();\n        }\n        if (msg.value > 0) {\n            uint256 assignBp;\n            FeeConfigOverride storage feeOverride = _scopeFeeOverrides[scopeName];\n            if (feeOverride.active) {\n                assignBp = feeOverride.assignBp;\n            } else {\n                assignBp = _protocolFeeConfig.assignBp;\n            }\n            uint256 protocolFee = msg.value * assignBp / _FEE_BASIS_DENOM;\n            _protocolBalance += protocolFee;\n            scope.balance += msg.value - protocolFee;\n        }\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-assign}\n    */\n    function assign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId) public payable mustNotBeFrozen(target, targetTokenId) {\n        address targetOwner = IERC721(target).ownerOf(targetTokenId);\n        uint64 ref = _doAssign(fragment, fragmentTokenId, target, targetTokenId, targetOwner);\n        IPatchworkLiteRef(target).addReference(targetTokenId, ref);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-assign}\n    */\n    function assign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, uint256 targetMetadataId) public payable mustNotBeFrozen(target, targetTokenId) {\n        address targetOwner = IERC721(target).ownerOf(targetTokenId);\n        uint64 ref = _doAssign(fragment, fragmentTokenId, target, targetTokenId, targetOwner);\n        IPatchworkLiteRef(target).addReference(targetTokenId, ref, targetMetadataId);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-assignBatch}\n    */\n    function assignBatch(address[] calldata fragments, uint[] calldata tokenIds, address target, uint targetTokenId) public payable mustNotBeFrozen(target, targetTokenId) {\n        (uint64[] memory refs, ) = _batchAssignCommon(fragments, tokenIds, target, targetTokenId);\n        IPatchworkLiteRef(target).addReferenceBatch(targetTokenId, refs);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-assignBatch}\n    */\n    function assignBatch(address[] calldata fragments, uint[] calldata tokenIds, address target, uint targetTokenId, uint256 targetMetadataId) public payable mustNotBeFrozen(target, targetTokenId) {\n        (uint64[] memory refs, ) = _batchAssignCommon(fragments, tokenIds, target, targetTokenId);\n        IPatchworkLiteRef(target).addReferenceBatch(targetTokenId, refs, targetMetadataId);\n    }\n\n    /**\n    @dev Common function to handle the batch assignments.\n    */\n    function _batchAssignCommon(address[] calldata fragments, uint[] calldata tokenIds, address target, uint targetTokenId) private returns (uint64[] memory refs, address targetOwner) {\n        if (fragments.length != tokenIds.length) {\n            revert BadInputLengths();\n        }\n        targetOwner = IERC721(target).ownerOf(targetTokenId);\n        refs = new uint64[](fragments.length);\n        for (uint i = 0; i < fragments.length; i++) {\n            address fragment = fragments[i];\n            uint256 fragmentTokenId = tokenIds[i];\n            refs[i] = _doAssign(fragment, fragmentTokenId, target, targetTokenId, targetOwner);\n        }\n    }\n\n    /**\n    @notice Performs assignment of an IPatchworkAssignable to an IPatchworkLiteRef\n    @param fragment the IPatchworkAssignable's address\n    @param fragmentTokenId the IPatchworkAssignable's tokenId\n    @param target the IPatchworkLiteRef target's address\n    @param targetTokenId the IPatchworkLiteRef target's tokenId\n    @param targetOwner the owner address of the target\n    @return uint64 literef of assignable in target\n    */\n    function _doAssign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, address targetOwner) private mustNotBeFrozen(fragment, fragmentTokenId) returns (uint64) {\n        if (fragment == target && fragmentTokenId == targetTokenId) {\n            revert SelfAssignmentNotAllowed(fragment, fragmentTokenId);\n        }\n        IPatchworkAssignable assignable = IPatchworkAssignable(fragment);\n        if (_isLocked(fragment, fragmentTokenId)) {\n            revert Locked(fragment, fragmentTokenId);\n        }\n        // Use the target's scope for general permission and check the fragment for detailed permissions\n        string memory targetScopeName = _getScopeName(target);\n        Scope storage targetScope = _mustHaveScope(targetScopeName);\n        _mustBeWhitelisted(targetScopeName, targetScope, target);\n        {\n            // Whitelist check, these variables do not need to stay in the function level stack\n            string memory fragmentScopeName = _getScopeName(fragment);\n            Scope storage fragmentScope = _mustHaveScope(fragmentScopeName);\n            _mustBeWhitelisted(fragmentScopeName, fragmentScope, fragment);\n            _handleAssignFee(fragmentScopeName, fragmentScope, fragment);\n        }\n        if (targetScope.owner == msg.sender || targetScope.operators[msg.sender]) {\n            // all good\n        } else if (targetScope.allowUserAssign) {\n            // msg.sender must own the target\n            if (targetOwner != msg.sender) {\n                revert NotAuthorized(msg.sender);\n            }\n        } else {\n            revert NotAuthorized(msg.sender);\n        }\n        if (!IPatchworkAssignable(fragment).allowAssignment(fragmentTokenId, target, targetTokenId, targetOwner, msg.sender, targetScopeName)) {\n            revert NotAuthorized(msg.sender);\n        }\n        bytes32 targetRef;\n        // reduce stack to stay under limit\n        address _target = target;\n        uint256 _targetTokenId = targetTokenId;\n        address _fragment = fragment;\n        uint256 _fragmentTokenId = fragmentTokenId;\n        (uint64 ref, bool redacted) = IPatchworkLiteRef(_target).getLiteReference(_fragment, _fragmentTokenId);\n        // targetRef is a compound key (targetAddr+targetTokenID+fragmentAddr+fragmentTokenID) - blocks duplicate assignments\n        targetRef = keccak256(abi.encodePacked(_target, _targetTokenId, ref));\n        if (ref == 0) {\n            revert FragmentUnregistered(address(_fragment));\n        }\n        if (redacted) {\n            revert FragmentRedacted(address(_fragment));\n        }\n        if (_liteRefs[targetRef]) {\n            revert FragmentAlreadyAssigned(address(_fragment), _fragmentTokenId);\n        }\n        // call assign on the fragment\n        assignable.assign(_fragmentTokenId, _target, _targetTokenId);\n        // add to our storage of assignments\n        _liteRefs[targetRef] = true;\n        emit Assign(targetOwner, _fragment, _fragmentTokenId, _target, _targetTokenId);\n        return ref;\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-unassign}\n    */\n    function unassign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId) public mustNotBeFrozen(target, targetTokenId) {\n        _unassign(fragment, fragmentTokenId, target, targetTokenId, false, 0);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-unassign}\n    */\n    function unassign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, uint256 targetMetadataId) public mustNotBeFrozen(target, targetTokenId) {\n        _unassign(fragment, fragmentTokenId, target, targetTokenId, true, targetMetadataId);\n    }\n\n    /**\n    @dev Common function to handle unassignments.\n    */\n    function _unassign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, bool isDirect, uint256 targetMetadataId) private {\n        if (IERC165(fragment).supportsInterface(type(IPatchworkMultiAssignable).interfaceId)) {\n            if (isDirect) {\n                unassignMulti(fragment, fragmentTokenId, target, targetTokenId, targetMetadataId);\n            } else {\n                unassignMulti(fragment, fragmentTokenId, target, targetTokenId);\n            }\n        } else if (IERC165(fragment).supportsInterface(type(IPatchworkSingleAssignable).interfaceId)) {\n            (address _target, uint256 _targetTokenId) = IPatchworkSingleAssignable(fragment).getAssignedTo(fragmentTokenId);\n            if (target != _target || _targetTokenId != targetTokenId) {\n                revert FragmentNotAssignedToTarget(fragment, fragmentTokenId, target, targetTokenId);\n            }\n            if (isDirect) {\n                unassignSingle(fragment, fragmentTokenId, targetMetadataId);\n            } else {\n                unassignSingle(fragment, fragmentTokenId);\n            }\n        } else {\n            revert UnsupportedContract();\n        }\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-unassignMulti}\n    */\n    function unassignMulti(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId) public mustNotBeFrozen(target, targetTokenId) {\n        _unassignMultiCommon(fragment, fragmentTokenId, target, targetTokenId, false, 0);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-unassignMulti}\n    */\n    function unassignMulti(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, uint256 targetMetadataId) public mustNotBeFrozen(target, targetTokenId) {\n        _unassignMultiCommon(fragment, fragmentTokenId, target, targetTokenId, true, targetMetadataId);\n    }\n\n    /**\n    @dev Common function to handle the unassignment of multi assignables.\n    */\n    function _unassignMultiCommon(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, bool isDirect, uint256 targetMetadataId) private {\n        IPatchworkMultiAssignable assignable = IPatchworkMultiAssignable(fragment);\n        if (!assignable.isAssignedTo(fragmentTokenId, target, targetTokenId)) {\n            revert FragmentNotAssignedToTarget(fragment, fragmentTokenId, target, targetTokenId);\n        }\n        string memory scopeName = _getScopeName(target);\n        _doUnassign(fragment, fragmentTokenId, target, targetTokenId, isDirect, targetMetadataId, scopeName);\n        assignable.unassign(fragmentTokenId, target, targetTokenId);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-unassignSingle}\n    */\n    function unassignSingle(address fragment, uint fragmentTokenId) public mustNotBeFrozen(fragment, fragmentTokenId) {\n        _unassignSingleCommon(fragment, fragmentTokenId, false, 0);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-unassignSingle}\n    */\n    function unassignSingle(address fragment, uint fragmentTokenId, uint256 targetMetadataId) public mustNotBeFrozen(fragment, fragmentTokenId) {\n        _unassignSingleCommon(fragment, fragmentTokenId, true, targetMetadataId);\n    }\n\n    /**\n    @dev Common function to handle the unassignment of single assignables.\n    */\n    function _unassignSingleCommon(address fragment, uint fragmentTokenId, bool isDirect, uint256 targetMetadataId) private {\n        IPatchworkSingleAssignable assignable = IPatchworkSingleAssignable(fragment);\n        (address target, uint256 targetTokenId) = assignable.getAssignedTo(fragmentTokenId);\n        if (target == address(0)) {\n            revert FragmentNotAssigned(fragment, fragmentTokenId);\n        }\n        string memory scopeName = _getScopeName(target);\n        _doUnassign(fragment, fragmentTokenId, target, targetTokenId, isDirect, targetMetadataId, scopeName);\n        assignable.unassign(fragmentTokenId);\n    }\n\n    /**\n    @notice Performs unassignment of an IPatchworkAssignable to an IPatchworkLiteRef\n    @param fragment the IPatchworkAssignable's address\n    @param fragmentTokenId the IPatchworkAssignable's tokenId\n    @param target the IPatchworkLiteRef target's address\n    @param targetTokenId the IPatchworkLiteRef target's tokenId\n    @param direct If this is calling the direct function\n    @param targetMetadataId the metadataId to use on the target\n    @param scopeName the name of the target's scope\n    */\n    function _doUnassign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, bool direct, uint256 targetMetadataId, string memory scopeName) private {\n        Scope storage scope = _mustHaveScope(scopeName);\n        if (scope.owner == msg.sender || scope.operators[msg.sender]) {\n            // continue\n        } else if (scope.allowUserAssign) {\n            if (IERC721(target).ownerOf(targetTokenId) != msg.sender) {\n                revert NotAuthorized(msg.sender);\n            }\n            // continue\n        } else {\n            revert NotAuthorized(msg.sender);\n        }\n        (uint64 ref, ) = IPatchworkLiteRef(target).getLiteReference(fragment, fragmentTokenId);\n        if (ref == 0) {\n            revert FragmentUnregistered(address(fragment));\n        }\n        bytes32 targetRef = keccak256(abi.encodePacked(target, targetTokenId, ref));\n        if (!_liteRefs[targetRef]) {\n            revert RefNotFound(target, fragment, fragmentTokenId);\n        }\n        delete _liteRefs[targetRef];\n        if (direct) {\n            IPatchworkLiteRef(target).removeReference(targetTokenId, ref, targetMetadataId);\n        } else {\n            IPatchworkLiteRef(target).removeReference(targetTokenId, ref);\n        }\n\n        emit Unassign(IERC721(fragment).ownerOf(fragmentTokenId), fragment, fragmentTokenId, target, targetTokenId);\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-applyTransfer}\n    */\n    function applyTransfer(address from, address to, uint256 tokenId) public {\n        address nft = msg.sender;\n        if (IERC165(nft).supportsInterface(type(IPatchworkSingleAssignable).interfaceId)) {\n            IPatchworkSingleAssignable assignable = IPatchworkSingleAssignable(nft);\n            (address addr,) = assignable.getAssignedTo(tokenId);\n            if (addr != address(0)) {\n                revert TransferBlockedByAssignment(nft, tokenId);\n            }\n        }\n        if (IERC165(nft).supportsInterface(type(IPatchworkPatch).interfaceId)) {\n            revert TransferNotAllowed(nft, tokenId);\n        }\n        if (IERC165(nft).supportsInterface(type(IPatchwork721).interfaceId)) {\n            if (IPatchwork721(nft).locked(tokenId)) {\n                revert Locked(nft, tokenId);\n            }\n        }\n        if (IERC165(nft).supportsInterface(type(IPatchworkLiteRef).interfaceId)) {\n            (address[] memory addresses, uint256[] memory tokenIds) = IPatchworkLiteRef(nft).loadAllStaticReferences(tokenId);\n            for (uint i = 0; i < addresses.length; i++) {\n                if (addresses[i] != address(0)) {\n                    _applyAssignedTransfer(addresses[i], from, to, tokenIds[i], nft, tokenId);\n                }\n            }\n        }\n    }\n\n    function _applyAssignedTransfer(address nft, address from, address to, uint256 tokenId, address assignedTo_, uint256 assignedToTokenId_) private {\n        if (!IERC165(nft).supportsInterface(type(IPatchworkSingleAssignable).interfaceId)) {\n            revert NotPatchworkAssignable(nft);\n        }\n        (address assignedTo, uint256 assignedToTokenId) = IPatchworkSingleAssignable(nft).getAssignedTo(tokenId);\n        // 2-way Check the assignment to prevent spoofing\n        if (assignedTo_ != assignedTo || assignedToTokenId_ != assignedToTokenId) {\n            revert DataIntegrityError(assignedTo_, assignedToTokenId_, assignedTo, assignedToTokenId);\n        }\n        IPatchworkSingleAssignable(nft).onAssignedTransfer(from, to, tokenId);\n        if (IERC165(nft).supportsInterface(type(IPatchworkLiteRef).interfaceId)) {\n            address nft_ = nft; // local variable prevents optimizer stack issue in v0.8.18\n            (address[] memory addresses, uint256[] memory tokenIds) = IPatchworkLiteRef(nft).loadAllStaticReferences(tokenId);\n            for (uint i = 0; i < addresses.length; i++) {\n                if (addresses[i] != address(0)) {\n                    _applyAssignedTransfer(addresses[i], from, to, tokenIds[i], nft_, tokenId);\n                }\n            }\n        }\n    }\n\n    /**\n    @dev See {IPatchworkProtocol-updateOwnershipTree}\n    */ \n    function updateOwnershipTree(address addr, uint256 tokenId) public {\n        if (IERC165(addr).supportsInterface(type(IPatchworkLiteRef).interfaceId)) {\n            (address[] memory addresses, uint256[] memory tokenIds) = IPatchworkLiteRef(addr).loadAllStaticReferences(tokenId);\n            for (uint i = 0; i < addresses.length; i++) {\n                if (addresses[i] != address(0)) {\n                    updateOwnershipTree(addresses[i], tokenIds[i]);\n                }\n            }\n        }\n        if (IERC165(addr).supportsInterface(type(IPatchworkSingleAssignable).interfaceId)) {\n            IPatchworkSingleAssignable(addr).updateOwnership(tokenId);\n        } else if (IERC165(addr).supportsInterface(type(IPatchworkPatch).interfaceId)) {\n            IPatchworkPatch(addr).updateOwnership(tokenId);\n        }\n    }\n\n    /**\n    @notice Requires that scopeName is present\n    @dev will revert with ScopeDoesNotExist if not present\n    @return scope the scope\n    */\n    function _mustHaveScope(string memory scopeName) private view returns (Scope storage scope) {\n        scope = _scopes[scopeName];\n        if (scope.owner == address(0)) {\n            revert ScopeDoesNotExist(scopeName);\n        }\n    }\n\n    /**\n    @notice Requires that addr is whitelisted if whitelisting is enabled\n    @dev will revert with NotWhitelisted if whitelisting is enabled and address is not whitelisted\n    @param scopeName the name of the scope\n    @param scope the scope\n    @param addr the address to check\n    */\n    function _mustBeWhitelisted(string memory scopeName, Scope storage scope, address addr) private view {\n        if (scope.requireWhitelist && !scope.whitelist[addr]) {\n            revert NotWhitelisted(scopeName, addr);\n        }\n    }\n\n    /**\n    @notice Requires that msg.sender is owner of scope\n    @dev will revert with NotAuthorized if msg.sender is not owner\n    @param scope the scope\n    */\n    function _mustBeOwner(Scope storage scope) private view {\n        if (msg.sender != scope.owner) {\n            revert NotAuthorized(msg.sender);\n        }\n    }\n\n    /**\n    @notice Requires that msg.sender is owner or operator of scope\n    @dev will revert with NotAuthorized if msg.sender is not owner or operator\n    @param scope the scope\n    */\n    function _mustBeOwnerOrOperator(Scope storage scope) private view {\n        if (msg.sender != scope.owner && !scope.operators[msg.sender]) {\n            revert NotAuthorized(msg.sender);\n        }\n    }\n\n    /**\n    @notice Requires that nft is not frozen\n    @dev will revert with Frozen if nft is frozen\n    @param nft the address of nft\n    @param tokenId the tokenId of nft\n    */\n    modifier mustNotBeFrozen(address nft, uint256 tokenId) {\n        if (_isFrozen(nft, tokenId)) {\n            revert Frozen(nft, tokenId);\n        }\n        _;\n    }\n\n    /**\n    @notice Determines if nft is frozen using ownership hierarchy\n    @param nft the address of nft\n    @param tokenId the tokenId of nft\n    @return frozen if the nft or an owner up the tree is frozen\n    */\n    function _isFrozen(address nft, uint256 tokenId) private view returns (bool frozen) {\n        if (IERC165(nft).supportsInterface(type(IPatchwork721).interfaceId)) {\n            if (IPatchwork721(nft).frozen(tokenId)) {\n                return true;\n            }\n            if (IERC165(nft).supportsInterface(type(IPatchworkSingleAssignable).interfaceId)) {\n                (address assignedAddr, uint256 assignedTokenId) = IPatchworkSingleAssignable(nft).getAssignedTo(tokenId);\n                if (assignedAddr != address(0)) {\n                    return _isFrozen(assignedAddr, assignedTokenId);\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n    @notice Determines if nft is locked\n    @param nft the address of nft\n    @param tokenId the tokenId of nft\n    @return locked if the nft is locked\n    */\n    function _isLocked(address nft, uint256 tokenId) private view returns (bool locked) {\n        if (IERC165(nft).supportsInterface(type(IPatchwork721).interfaceId)) {\n            if (IPatchwork721(nft).locked(tokenId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n    @notice Memoizing wrapper for IPatchworkScoped.getScopeName()\n    @param addr Address to check\n    @return scopeName return value of IPatchworkScoped(addr).getScopeName()\n    */\n    function _getScopeName(address addr) private returns (string memory scopeName) {\n        scopeName = _scopeNameCache[addr];\n        if (bytes(scopeName).length == 0) {\n            scopeName = IPatchworkScoped(addr).getScopeName();\n            _scopeNameCache[addr] = scopeName;\n        }\n    }\n\n    /**\n    @notice Memoized view-only wrapper for IPatchworkScoped.getScopeName()\n    @dev required to get optimized result from view-only functions, does not memoize result if not already memoized\n    @param addr Address to check\n    @return scopeName return value of IPatchworkScoped(addr).getScopeName()\n    */\n    function _getScopeNameViewOnly(address addr) private view returns (string memory scopeName) {\n        scopeName = _scopeNameCache[addr];\n        if (bytes(scopeName).length == 0) {\n            scopeName = IPatchworkScoped(addr).getScopeName();\n        }\n    }\n\n    modifier onlyProtoOwnerBanker() {\n        if (msg.sender != owner() && _protocolBankers[msg.sender] == false) {\n            revert NotAuthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyFrom(address addr) {\n        if (msg.sender != addr) {\n            revert NotAuthorized(msg.sender);\n        }\n        _;\n    }\n}"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"},"src/interfaces/IPatchwork721.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"./IERC5192.sol\";\nimport \"./IPatchworkScoped.sol\";\n\n/** \n@title Patchwork Protocol Interface Metadata\n@author Runic Labs, Inc\n@notice Metadata for IPatchwork721 and related contract interfaces\n*/\ninterface IPatchworkMetadata {\n    /**\n    @notice Enumeration of possible field data types.\n    @dev This defines the various basic data types for the fields.\n     */\n    enum FieldType {\n        BOOLEAN,  ///< A Boolean type (true or false).\n        INT8,     ///< An 8-bit signed integer.\n        INT16,    ///< A 16-bit signed integer.\n        INT32,    ///< A 32-bit signed integer.\n        INT64,    ///< A 64-bit signed integer.\n        INT128,   ///< A 128-bit signed integer.\n        INT256,   ///< A 256-bit signed integer.\n        UINT8,    ///< An 8-bit unsigned integer.\n        UINT16,   ///< A 16-bit unsigned integer.\n        UINT32,   ///< A 32-bit unsigned integer.\n        UINT64,   ///< A 64-bit unsigned integer.\n        UINT128,  ///< A 128-bit unsigned integer.\n        UINT256,  ///< A 256-bit unsigned integer.\n        CHAR8,    ///< An 8-character string.\n        CHAR16,   ///< A 16-character string.\n        CHAR32,   ///< A 32-character string.\n        CHAR64,   ///< A 64-character string.\n        LITEREF  ///< A Literef reference to a patchwork fragment\n    }\n\n    /**\n    @notice Struct defining the metadata schema.\n    @dev This defines the overall structure of the metadata and contains entries describing each data field.\n    */\n    struct MetadataSchema {\n        uint256 version;                    ///< Version of the metadata schema.\n        MetadataSchemaEntry[] entries;      ///< Array of entries in the schema.\n    }\n\n    /**\n    @notice Struct defining individual entries within the metadata schema.\n    @dev Represents each data field in the schema, detailing its properties and type.\n    */\n    struct MetadataSchemaEntry {\n        uint256 id;                        ///< Index or unique identifier of the entry.\n        uint256 permissionId;              ///< Permission identifier associated with the entry.\n        FieldType fieldType;               ///< Type of field data (from the FieldType enum).\n        uint256 fieldCount;                ///< Number of elements of this field (0 = Dynamic Array, 1 = Single, >1 = Static Array)\n        FieldVisibility visibility;        ///< Visibility level of the field.\n        uint256 slot;                      ///< Starting storage slot, may span multiple slots based on width.\n        uint256 offset;                    ///< Offset in bits within the storage slot.\n        string key;                        ///< Key or name associated with the field.\n    }\n\n    /**\n    @notice Enumeration of field visibility options.\n    @dev Specifies whether a field is publicly accessible or private.\n    */\n    enum FieldVisibility {\n        PUBLIC,  ///< Field is publicly accessible.\n        PRIVATE  ///< Field is private\n    }\n}\n\n/**\n@title Patchwork Protocol 721 Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork metadata standard\n*/\ninterface IPatchwork721 is IPatchworkScoped, IPatchworkMetadata, IERC5192, IERC721 {\n    /**\n    @notice Emitted when the freeze status is changed to frozen.\n    @param tokenId The identifier for a token.\n    */\n    event Frozen(uint256 indexed tokenId);\n\n    /**\n    @notice Emitted when the locking status is changed to not frozen.\n    @param tokenId The identifier for a token.\n    */\n    event Thawed(uint256 indexed tokenId);\n\n    /**\n    @notice Emitted when the permissions are changed\n    @param to The address the permissions are assigned to\n    @param permissions The permissions\n    */\n    event PermissionChange(address indexed to, uint256 permissions);\n\n    /**\n    @notice Emitted when the schema has changed\n    @param addr the address of the Patchwork721\n    */\n    event SchemaChange(address indexed addr);\n    \n    /**\n    @notice Returns the URI of the schema\n    @return string the URI of the schema\n    */\n    function schemaURI() external view returns (string memory);\n\n    /**\n    @notice Returns the metadata schema\n    @return MetadataSchema the metadata schema\n    */\n    function schema() external view returns (MetadataSchema memory);\n\n    /**\n    @notice Returns the URI of the image associated with the given token ID\n    @param tokenId ID of the token\n    @return string the image URI\n    */\n    function imageURI(uint256 tokenId) external view returns (string memory);\n\n    /**\n    @notice Sets permissions for a given address\n    @param to Address to set permissions for\n    @param permissions Permissions value\n    */\n    function setPermissions(address to, uint256 permissions) external;\n\n    /**\n    @notice Stores packed metadata for a given token ID and slot\n    @param tokenId ID of the token\n    @param slot Slot to store metadata\n    @param data Metadata to store\n    */\n    function storePackedMetadataSlot(uint256 tokenId, uint256 slot, uint256 data) external;\n\n    /**\n    @notice Stores packed metadata for a given token ID\n    @param tokenId ID of the token\n    @param data Metadata to store\n    */\n    function storePackedMetadata(uint256 tokenId, uint256[] memory data) external;\n\n    /**\n    @notice Loads packed metadata for a given token ID and slot\n    @param tokenId ID of the token\n    @param slot Slot to load metadata from\n    @return uint256 the raw slot data as a uint256\n    */\n    function loadPackedMetadataSlot(uint256 tokenId, uint256 slot) external view returns (uint256);\n\n    /**\n    @notice Loads packed metadata for a given token ID\n    @param tokenId ID of the token\n    @return uint256[] the raw slot data as a uint256 array\n    */\n    function loadPackedMetadata(uint256 tokenId) external view returns (uint256[] memory);\n\n    /**\n    @notice Returns the freeze nonce for a given token ID\n    @param tokenId ID of the token\n    @return nonce the nonce\n    */\n    function getFreezeNonce(uint256 tokenId) external view returns (uint256 nonce);\n\n    /**\n    @notice Sets the freeze status of a token\n    @param tokenId ID of the token\n    @param frozen Freeze status to set\n    */\n    function setFrozen(uint256 tokenId, bool frozen) external;\n\n    /**\n    @notice Gets the freeze status of a token (ERC-5192)\n    @param tokenId ID of the token\n    @return bool true if frozen, false if not\n     */\n    function frozen(uint256 tokenId) external view returns (bool);\n\n    /**\n    @notice Sets the lock status of a token\n    @param tokenId ID of the token\n    @param locked Lock status to set\n    */\n    function setLocked(uint256 tokenId, bool locked) external;\n}"},"src/interfaces/IPatchworkSingleAssignable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IPatchworkAssignable.sol\";\n\n/**\n@title Patchwork Protocol Assignable Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork assignment\n*/\ninterface IPatchworkSingleAssignable is IPatchworkAssignable {\n    /**\n    @notice Unassigns a token\n    @param ourTokenId ID of our token\n    */\n    function unassign(uint256 ourTokenId) external;\n\n    /**\n    @notice Returns the address and token ID that our token is assigned to\n    @param ourTokenId ID of our token\n    @return address the address this is assigned to\n    @return uint256 the tokenId this is assigned to\n    */\n    function getAssignedTo(uint256 ourTokenId) external view returns (address, uint256);\n\n    /**\n    @notice Returns the underlying stored owner of a token ignoring current assignment\n    @param ourTokenId ID of our token\n    @return address address of the owner\n    */\n    function unassignedOwnerOf(uint256 ourTokenId) external view returns (address);\n\n    /**\n    @notice Sends events for a token when the assigned-to token has been transferred\n    @param from Sender address\n    @param to Recipient address\n    @param tokenId ID of the token\n    */\n    function onAssignedTransfer(address from, address to, uint256 tokenId) external;\n\n    /**\n    @notice Updates the real underlying ownership of a token in storage (if different from current)\n    @param tokenId ID of the token\n    */\n    function updateOwnership(uint256 tokenId) external;\n}"},"src/interfaces/IPatchworkMultiAssignable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IPatchworkAssignable.sol\";\n\n/**\n@title Patchwork Protocol Assignable NFT Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork assignment\n*/\ninterface IPatchworkMultiAssignable is IPatchworkAssignable {\n\n    /**\n    @notice Checks if this fragment is assigned to a target\n    @param ourTokenId the tokenId of the fragment\n    @param target the address of the target\n    @param targetTokenId the tokenId of the target\n    */\n    function isAssignedTo(uint256 ourTokenId, address target, uint256 targetTokenId) external view returns (bool);\n\n    /**\n    @notice Unassigns a token\n    @param ourTokenId tokenId of our fragment\n    */\n    function unassign(uint256 ourTokenId, address target, uint256 targetTokenId) external;\n\n    /**\n    @notice Counts the number of unique assignments this token has\n    @param tokenId tokenId of our fragment\n    */\n    function getAssignmentCount(uint256 tokenId) external view returns (uint256);\n\n    /**\n    @notice Gets assignments for a fragment\n    @param tokenId tokenId of our fragment\n    @param offset the page offset\n    @param count the maximum numer of entries to return\n    */\n    function getAssignments(uint256 tokenId, uint256 offset, uint256 count) external view returns (Assignment[] memory);\n}"},"src/interfaces/IPatchworkLiteRef.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n@title Patchwork Protocol LiteRef NFT Interface\n@author Runic Labs, Inc\n@notice Interface for contracts that have Lite Reference ID support\n*/\ninterface IPatchworkLiteRef {\n    /**\n    @notice Emitted when a contract redacts a fragment\n    @param target the contract which issued the redaction\n    @param fragment the fragment that was redacted\n    */\n    event Redact(address indexed target, address indexed fragment);\n\n    /**\n    @notice Emitted when a contract unredacts a fragment\n    @param target the contract which revoked the redaction\n    @param fragment the fragment that was unredacted\n    */\n    event Unredact(address indexed target, address indexed fragment);\n\n    /**\n    @notice Emitted when a contract registers a fragment\n    @param target the contract that registered the fragment\n    @param fragment the fragment that was registered\n    @param idx the idx of the literef\n    */\n    event Register(address indexed target, address indexed fragment, uint8 idx);\n\n    /**\n    @notice Registers a reference address\n    @param addr Address to register\n    @return id ID assigned to the address\n    */\n    function registerReferenceAddress(address addr) external returns (uint8 id);\n\n    /**\n    @notice Gets the ID assigned to the address from registration\n    @param addr Registered address\n    @return id ID assigned to the address\n    @return redacted Redacted status\n    */\n    function getReferenceId(address addr) external view returns (uint8 id, bool redacted);\n\n    /**\n    @notice Gets the address assigned to this id\n    @param id ID assigned to the address\n    @return addr Registered address\n    @return redacted Redacted status\n    */\n    function getReferenceAddress(uint8 id) external view returns (address addr, bool redacted);\n\n    /**\n    @notice Redacts a reference address\n    @param id ID of the address to redact\n    */\n    function redactReferenceAddress(uint8 id) external;\n\n    /**\n    @notice Unredacts a reference address\n    @param id ID of the address to unredact\n    */\n    function unredactReferenceAddress(uint8 id) external;\n\n    /**\n    @notice Returns a lite reference for a given address and token ID\n    @param addr Address to get reference for\n    @param tokenId ID of the token\n    @return liteRef Lite reference\n    @return redacted Redacted status\n    */\n    function getLiteReference(address addr, uint256 tokenId) external view returns (uint64 liteRef, bool redacted);\n\n    /**\n    @notice Returns an address and token ID for a given lite reference\n    @param liteRef Lite reference to get address and token ID for\n    @return addr Address\n    @return tokenId Token ID\n    */\n    function getReferenceAddressAndTokenId(uint64 liteRef) external view returns (address addr, uint256 tokenId);\n\n    /**\n    @notice Adds a reference to a token\n    @param tokenId ID of the token\n    @param liteRef LiteRef to add\n    */\n    function addReference(uint256 tokenId, uint64 liteRef) external;\n\n    /**\n    @notice Adds a reference to a token\n    @param tokenId ID of the token\n    @param liteRef LiteRef to add\n    @param targetMetadataId The metadata ID on the target to assign to\n    */\n    function addReference(uint256 tokenId, uint64 liteRef, uint256 targetMetadataId) external;\n\n    /**\n    @notice Adds multiple references to a token\n    @param tokenId ID of the token\n    @param liteRefs Array of lite references to add\n    */\n    function addReferenceBatch(uint256 tokenId, uint64[] calldata liteRefs) external;\n\n    /**\n    @notice Adds multiple references to a token\n    @param tokenId ID of the token\n    @param liteRefs Array of lite references to add\n    @param targetMetadataId The metadata ID on the target to assign to\n    */\n    function addReferenceBatch(uint256 tokenId, uint64[] calldata liteRefs, uint256 targetMetadataId) external;\n\n    /**\n    @notice Removes a reference from a token\n    @param tokenId ID of the token\n    @param liteRef Lite reference to remove\n    */\n    function removeReference(uint256 tokenId, uint64 liteRef) external;\n\n    /**\n    @notice Removes a reference from a token\n    @param tokenId ID of the token\n    @param liteRef Lite reference to remove\n    @param targetMetadataId The metadata ID on the target to unassign from\n    */\n    function removeReference(uint256 tokenId, uint64 liteRef, uint256 targetMetadataId) external;\n\n    /**\n    @notice Loads a reference address and token ID at a given index\n    @param ourTokenId ID of the token\n    @param idx Index to load from\n    @return addr Address\n    @return tokenId Token ID\n    */\n    function loadReferenceAddressAndTokenId(uint256 ourTokenId, uint256 idx) external view returns (address addr, uint256 tokenId);\n\n    /**\n    @notice Loads all static references for a given token ID\n    @param tokenId ID of the token\n    @return addresses Array of addresses\n    @return tokenIds Array of token IDs\n    */\n    function loadAllStaticReferences(uint256 tokenId) external view returns (address[] memory addresses, uint256[] memory tokenIds);\n\n    /**\n    @notice Count all dynamic references for a given token ID\n    @param tokenId ID of the token\n    @return count the number of dynamic references\n    */\n    function getDynamicReferenceCount(uint256 tokenId) external view returns (uint256 count);\n\n    /**\n    @notice Load a page of dynamic references for a given token ID\n    @param tokenId ID of the token\n    @param offset The starting offset 0-indexed\n    @param count The maximum number of references to return\n    @return addresses An array of reference addresses\n    @return tokenIds An array of reference token IDs\n    */\n    function loadDynamicReferencePage(uint256 tokenId, uint256 offset, uint256 count) external view returns (address[] memory addresses, uint256[] memory tokenIds);\n}\n"},"src/interfaces/IPatchworkPatch.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IPatchworkScoped.sol\";\n\n/**\n@title Patchwork Protocol Patch Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork patch standard\n*/\ninterface IPatchworkPatch is IPatchworkScoped {\n    /// @dev A canonical path to an 721 patched\n    struct PatchTarget {\n        address addr;    // The address of the 721\n        uint256 tokenId; // The tokenId of the 721\n    }\n    \n    /**\n    @notice Creates a new token for the owner, representing a patch\n    @param owner Address of the owner of the token\n    @param target path to target of patch\n    @return tokenId ID of the newly minted token\n    */\n    function mintPatch(address owner, PatchTarget memory target) external payable returns (uint256 tokenId);\n\n    /**\n    @notice Updates the real underlying ownership of a token in storage (if different from current)\n    @param tokenId ID of the token\n    */\n    function updateOwnership(uint256 tokenId) external;\n\n    /**\n    @notice Returns the underlying stored owner of a token ignoring real patched NFT ownership\n    @param tokenId ID of the token\n    @return address Address of the owner\n    */\n    function ownerOfPatch(uint256 tokenId) external view returns (address);\n}\n\n/**\n@title Patchwork Protocol Reversible Patch Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork patch standard with reverse lookup\n*/\ninterface IPatchworkReversiblePatch is IPatchworkPatch {\n    /**\n    @notice Returns the token ID (if it exists) for an NFT that may have been patched\n    @dev Requires reverse storage enabled\n    @param target Patch to target of patch\n    @return tokenId token ID of the patch\n    */\n    function getTokenIdByTarget(PatchTarget memory target) external view returns (uint256 tokenId);\n}"},"src/interfaces/IPatchwork1155Patch.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IPatchworkScoped.sol\";\n\n/**\n@title Patchwork Protocol 1155 Patch Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork patch standard\n*/\ninterface IPatchwork1155Patch is IPatchworkScoped {\n    /// @dev A canonical path to an 1155 patched target\n    struct PatchTarget {\n        address addr;    // The address of the 1155\n        uint256 tokenId; // The tokenId of the 1155\n        address account; // The account for the 1155\n    }\n\n    /**\n    @notice Creates a new token for the owner, representing a patch\n    @param to Address of the owner of the patch token\n    @param target Path to an 1155 to patch\n    @return tokenId ID of the newly minted token\n    */\n    function mintPatch(address to, PatchTarget memory target) external payable returns (uint256 tokenId);\n}\n\n/**\n@title Patchwork Protocol Reversible 1155 Patch Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork patch standard with reverse lookup\n*/\ninterface IPatchworkReversible1155Patch is IPatchwork1155Patch {\n    /**\n    @notice Returns the token ID (if it exists) for an 1155 that may have been patched\n    @dev Requires reverse storage enabled\n    @param target The 1155 target that was patched\n    @return tokenId token ID of the patch\n    */\n    function getTokenIdByTarget(PatchTarget memory target) external returns (uint256 tokenId);\n}"},"src/interfaces/IPatchworkAccountPatch.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IPatchworkScoped.sol\";\n\n/**\n@title Patchwork Protocol Account Patch Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork patch standard\n*/\ninterface IPatchworkAccountPatch is IPatchworkScoped {\n    /**\n    @notice Creates a new token for the owner, representing a patch\n    @param owner Address of the owner of the token\n    @param target Address of the original account\n    @return tokenId ID of the newly minted token\n    */\n    function mintPatch(address owner, address target) external payable returns (uint256 tokenId);\n}\n\n/**\n@title Patchwork Protocol Reversible Account Patch Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork account patch standard with reverse lookup\n*/\ninterface IPatchworkReversibleAccountPatch is IPatchworkAccountPatch {\n    /**\n    @notice Returns the token ID (if it exists) for an NFT that may have been patched\n    @dev Requires reverse storage enabled\n    @param target Address of the original account\n    @return tokenId ID of the newly minted token\n    */\n    function getTokenIdByTarget(address target) external returns (uint256 tokenId);\n}"},"src/interfaces/IPatchworkProtocol.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n@title Patchwork Protocol Interface\n@author Runic Labs, Inc\n@notice Interface for Patchwork Protocol\n*/\ninterface IPatchworkProtocol {\n    /**\n    @notice The address is not authorized to perform this action\n    @param addr The address attempting to perform the action\n    */\n    error NotAuthorized(address addr);\n\n    /**\n    @notice The scope with the provided name already exists\n    @param scopeName Name of the scope\n    */\n    error ScopeExists(string scopeName);\n\n    /**\n    @notice The scope with the provided name does not exist\n    @param scopeName Name of the scope\n    */\n    error ScopeDoesNotExist(string scopeName);\n\n    /**\n    @notice Transfer of the scope to the provided address is not allowed\n    @param to Address not allowed for scope transfer\n    */\n    error ScopeTransferNotAllowed(address to);\n\n    /**\n    @notice The token with the provided ID at the given address is frozen\n    @param addr Address of the token owner\n    @param tokenId ID of the frozen token\n    */\n    error Frozen(address addr, uint256 tokenId);\n\n    /**\n    @notice The token with the provided ID at the given address is locked\n    @param addr Address of the token owner\n    @param tokenId ID of the locked token\n    */\n    error Locked(address addr, uint256 tokenId);\n\n    /**\n    @notice The address is not whitelisted for the given scope\n    @param scopeName Name of the scope\n    @param addr Address that isn't whitelisted\n    */\n    error NotWhitelisted(string scopeName, address addr);\n\n    /**\n    @notice The address at the given address has already been patched\n    @param addr The address that was patched\n    @param patchAddress Address of the patch applied\n    */\n    error AccountAlreadyPatched(address addr, address patchAddress);\n\n    /**\n    @notice The token at the given address has already been patched\n    @param addr Address of the original 721\n    @param tokenId ID of the patched token\n    @param patchAddress Address of the patch applied\n    */\n    error AlreadyPatched(address addr, uint256 tokenId, address patchAddress);\n\n    /**\n    @notice The ERC1155 path has already been patched\n    @param addr Address of the 1155\n    @param tokenId ID of the patched token\n    @param account The account patched\n    @param patchAddress Address of the patch applied\n    */\n    error ERC1155AlreadyPatched(address addr, uint256 tokenId, address account, address patchAddress);\n\n    /**\n    @notice The provided input lengths are not compatible or valid\n    @dev for any multi array inputs, they must be the same length\n    */\n    error BadInputLengths();\n\n    /**\n    @notice The fragment at the given address is unregistered\n    @param addr Address of the unregistered fragment\n    */\n    error FragmentUnregistered(address addr);\n\n    /**\n    @notice The fragment at the given address has been redacted\n    @param addr Address of the redacted fragment\n    */\n    error FragmentRedacted(address addr);\n\n    /**\n    @notice The fragment with the provided ID at the given address is already assigned\n    @param addr Address of the fragment\n    @param tokenId ID of the assigned fragment\n    */\n    error FragmentAlreadyAssigned(address addr, uint256 tokenId);\n\n    /**\n    @notice The reference was not found for the given fragment and target\n    @param target Address of the target token\n    @param fragment Address of the fragment\n    @param tokenId ID of the fragment\n    */\n    error RefNotFound(address target, address fragment, uint256 tokenId);\n\n    /**\n    @notice The fragment with the provided ID at the given address is not assigned\n    @param addr Address of the fragment\n    @param tokenId ID of the fragment\n    */\n    error FragmentNotAssigned(address addr, uint256 tokenId);\n\n    /**\n    @notice The fragment with the provided ID at the given address is not assigned to the target\n    @param addr Address of the fragment\n    @param tokenId ID of the fragment\n    @param targetAddress Address of the target\n    @param targetTokenId ID of the target\n    */\n    error FragmentNotAssignedToTarget(address addr, uint256 tokenId, address targetAddress, uint256 targetTokenId);\n\n    /**\n    @notice The fragment at the given address is already registered\n    @param addr Address of the registered fragment\n    */\n    error FragmentAlreadyRegistered(address addr);\n\n    /**\n    @notice Ran out of available IDs for allocation\n    @dev Max 255 IDs per target\n    */\n    error OutOfIDs();\n\n    /**\n    @notice The provided token ID is unsupported\n    @dev TokenIds may only be 56 bits long\n    @param tokenId The unsupported token ID\n    */\n    error UnsupportedTokenId(uint256 tokenId);\n\n    /**\n    @notice Cannot lock the soulbound patch at the given address\n    @param addr Address of the soulbound patch\n    */\n    error CannotLockSoulboundPatch(address addr);\n\n    /**\n    @notice The token with the provided ID at the given address is not frozen\n    @param addr Address of the token owner\n    @param tokenId ID of the token\n    */\n    error NotFrozen(address addr, uint256 tokenId);\n\n    /**\n    @notice The nonce for the token with the provided ID at the given address is incorrect\n    @dev It may be incorrect or a newer nonce may be present\n    @param addr Address of the token owner\n    @param tokenId ID of the token\n    @param nonce The incorrect nonce\n    */\n    error IncorrectNonce(address addr, uint256 tokenId, uint256 nonce);\n\n    /**\n    @notice Self assignment of the token with the provided ID at the given address is not allowed\n    @param addr Address of the token owner\n    @param tokenId ID of the token\n    */\n    error SelfAssignmentNotAllowed(address addr, uint256 tokenId);\n\n    /**\n    @notice Transfer of the token with the provided ID at the given address is not allowed\n    @param addr Address of the token owner\n    @param tokenId ID of the token\n    */\n    error TransferNotAllowed(address addr, uint256 tokenId);\n\n    /**\n    @notice Transfer of the token with the provided ID at the given address is blocked by an assignment\n    @param addr Address of the token owner\n    @param tokenId ID of the token\n    */\n    error TransferBlockedByAssignment(address addr, uint256 tokenId);\n\n    /**\n    @notice A rule is blocking the mint to this owner address\n    @param addr Address of the token owner\n    */\n    error MintNotAllowed(address addr);\n\n    /**\n    @notice The token at the given address is not IPatchworkAssignable\n    @param addr Address of the non-assignable token\n    */\n    error NotPatchworkAssignable(address addr);\n\n    /**\n    @notice A data integrity error has been detected\n    @dev Addr+TokenId is expected where addr2+tokenId2 is present\n    @param addr Address of the first token\n    @param tokenId ID of the first token\n    @param addr2 Address of the second token\n    @param tokenId2 ID of the second token\n    */\n    error DataIntegrityError(address addr, uint256 tokenId, address addr2, uint256 tokenId2);\n\n    /**\n    @notice The available balance does not satisfy the amount\n    */\n    error InsufficientFunds();\n\n    /**\n    @notice The supplied fee is not the corret amount\n    */\n    error IncorrectFeeAmount();\n\n    /**\n    @notice Minting is not active for this address \n    */\n    error MintNotActive();\n\n    /**\n    @notice The value could not be sent \n    */\n    error FailedToSend();   \n    \n    /**\n    @notice The contract is not supported\n    */\n    error UnsupportedContract();\n    \n    /**\n    @notice The operation is not supported\n    */\n    error UnsupportedOperation();\n\n    /**\n    @notice No proposed fee is set \n    */\n    error NoProposedFeeSet();\n\n    /**\n    @notice Timelock has not elapsed\n    */\n    error TimelockNotElapsed();\n\n    /**\n    @notice Invalid fee value \n    */\n    error InvalidFeeValue();\n\n    /** \n    @notice Fee Configuration\n    */\n    struct FeeConfig {\n        uint256 mintBp;   /// mint basis points (10000 = 100%)\n        uint256 patchBp;  /// patch basis points (10000 = 100%)\n        uint256 assignBp; /// assign basis points (10000 = 100%)\n    }\n\n    /** \n    @notice Fee Configuration Override\n    */\n    struct FeeConfigOverride {\n        uint256 mintBp;   /// mint basis points (10000 = 100%)\n        uint256 patchBp;  /// patch basis points (10000 = 100%)\n        uint256 assignBp; /// assign basis points (10000 = 100%)\n        bool active; /// true for present\n    }\n\n    /**\n    @notice Proposal to change a fee configuration for either protocol or scope override\n    */\n    struct ProposedFeeConfig {\n        FeeConfig config;\n        uint256 timestamp;\n        bool active; /// Used to enable/disable overrides - ignored for protocol\n    }\n\n    /**\n    @notice Mint configuration\n    */\n    struct MintConfig {\n        uint256 flatFee; /// fee per 1 quantity mint in wei\n        bool active;     /// If the mint is active\n    }\n\n    /**\n    @notice Represents a defined scope within the system\n    @dev Contains details about the scope ownership, permissions, and mappings for references and assignments\n    */\n    struct Scope {\n        /**\n        @notice Owner of this scope\n        @dev Address of the account or contract that owns this scope\n        */\n        address owner;\n\n        /**\n        @notice Owner-elect\n        @dev Used in two-step transfer process. If this is set, only this owner can accept the transfer\n        */\n        address ownerElect;\n\n        /**\n        @notice Indicates whether a user is allowed to patch within this scope\n        @dev True if a user can patch, false otherwise. If false, only operators and the scope owner can perform patching.\n        */\n        bool allowUserPatch;\n\n        /**\n        @notice Indicates whether a user is allowed to assign within this scope\n        @dev True if a user can assign, false otherwise. If false, only operators and the scope owner can perform assignments.\n        */\n        bool allowUserAssign;\n\n        /**\n        @notice Indicates if a whitelist is required for operations within this scope\n        @dev True if whitelist is required, false otherwise\n        */\n        bool requireWhitelist;\n\n        /**\n        @notice Mapped list of operator addresses for this scope\n        @dev Address of the operator mapped to a boolean indicating if they are an operator\n        */\n        mapping(address => bool) operators;\n\n        /**\n        @notice Mapped whitelist of addresses that belong to this scope\n        @dev Address mapped to a boolean indicating if it's whitelisted\n        */\n        mapping(address => bool) whitelist;\n\n        /**\n        @notice Mapped list of mint configurations for this scope\n        @dev Address of the IPatchworkMintable mapped to the configuration\n        */\n        mapping(address => MintConfig) mintConfigurations;\n\n        /**\n        @notice Mapped list of patch fees for this scope\n        @dev Address of a 721, 1155 or account patch mapped to the fee in wei \n        */\n        mapping(address => uint256) patchFees;\n\n        /**\n        @notice Mapped list of assign fees for this scope\n        @dev Address of an IPatchworkAssignable mapped to the fee in wei \n        */        \n        mapping(address => uint256) assignFees;\n\n        /**\n        @notice Balance in wei for this scope\n        @dev accrued in mint, patch and assign fees, may only be withdrawn by scope bankers\n        */\n        uint256 balance;\n\n        /**\n        @notice Mapped list of addresses that are designated bankers for this scope \n        @dev Address mapped to a boolean indicating if they are a banker\n        */\n        mapping(address => bool) bankers;\n    }\n\n    /**\n    @notice Emitted when a fragment is assigned\n    @param owner The owner of the target and fragment\n    @param fragmentAddress The address of the fragment's contract\n    @param fragmentTokenId The tokenId of the fragment\n    @param targetAddress The address of the target's contract\n    @param targetTokenId The tokenId of the target\n    */\n    event Assign(address indexed owner, address fragmentAddress, uint256 fragmentTokenId, address indexed targetAddress, uint256 indexed targetTokenId);\n\n    /**\n    @notice Emitted when a fragment is unassigned\n    @param owner The owner of the fragment\n    @param fragmentAddress The address of the fragment's contract\n    @param fragmentTokenId The tokenId of the fragment\n    @param targetAddress The address of the target's contract\n    @param targetTokenId The tokenId of the target\n    */\n    event Unassign(address indexed owner, address fragmentAddress, uint256 fragmentTokenId, address indexed targetAddress, uint256 indexed targetTokenId);\n\n    /**\n    @notice Emitted when a patch is minted\n    @param owner The owner of the patch\n    @param originalAddress The address of the original 721's contract\n    @param originalTokenId The tokenId of the original 721\n    @param patchAddress The address of the patch's contract\n    @param patchTokenId The tokenId of the patch\n    */\n    event Patch(address indexed owner, address originalAddress, uint256 originalTokenId, address indexed patchAddress, uint256 indexed patchTokenId);\n\n    /**\n    @notice Emitted when a patch is minted\n    @param owner The owner of the patch\n    @param originalAddress The address of the original 1155's contract\n    @param originalTokenId The tokenId of the original 1155\n    @param originalAccount The address of the original 1155's account\n    @param patchAddress The address of the patch's contract\n    @param patchTokenId The tokenId of the patch\n    */\n    event ERC1155Patch(address indexed owner, address originalAddress, uint256 originalTokenId, address originalAccount, address indexed patchAddress, uint256 indexed patchTokenId);\n\n\n    /**\n    @notice Emitted when an account patch is minted\n    @param owner The owner of the patch\n    @param originalAddress The address of the original account\n    @param patchAddress The address of the patch's contract\n    @param patchTokenId The tokenId of the patch\n    */\n    event AccountPatch(address indexed owner, address originalAddress, address indexed patchAddress, uint256 indexed patchTokenId);\n\n    /**\n    @notice Emitted when a new scope is claimed\n    @param scopeName The name of the claimed scope\n    @param owner The owner of the scope\n    */\n    event ScopeClaim(string scopeName, address indexed owner);\n\n    /**\n    @notice Emitted when a scope has elected a new owner to transfer to\n    @param scopeName The name of the transferred scope\n    @param from The owner of the scope\n    @param to The owner-elect of the scope\n    */\n    event ScopeTransferElect(string scopeName, address indexed from, address indexed to);\n\n    /**\n    @notice Emitted when a scope transfer is canceled\n    @param scopeName The name of the transferred scope\n    @param from The owner of the scope\n    @param to The owner-elect of the scope\n    */\n    event ScopeTransferCancel(string scopeName, address indexed from, address indexed to);\n\n    /**\n    @notice Emitted when a scope is transferred\n    @param scopeName The name of the transferred scope\n    @param from The address transferring the scope\n    @param to The recipient of the scope\n    */\n    event ScopeTransfer(string scopeName, address indexed from, address indexed to);\n\n    /**\n    @notice Emitted when a scope has an operator added\n    @param scopeName The name of the scope\n    @param actor The address responsible for the action\n    @param operator The new operator's address\n    */\n    event ScopeAddOperator(string scopeName, address indexed actor, address indexed operator);\n\n    /**\n    @notice Emitted when a scope has an operator removed\n    @param scopeName The name of the scope\n    @param actor The address responsible for the action\n    @param operator The operator's address being removed\n    */\n    event ScopeRemoveOperator(string scopeName, address indexed actor, address indexed operator);\n\n    /**\n    @notice Emitted when a scope's rules are changed\n    @param scopeName The name of the scope\n    @param actor The address responsible for the action\n    @param allowUserPatch Indicates whether user patches are allowed\n    @param allowUserAssign Indicates whether user assignments are allowed\n    @param requireWhitelist Indicates whether a whitelist is required\n    */\n    event ScopeRuleChange(string scopeName, address indexed actor, bool allowUserPatch, bool allowUserAssign, bool requireWhitelist);\n\n    /**\n    @notice Emitted when a scope has an address added to the whitelist\n    @param scopeName The name of the scope\n    @param actor The address responsible for the action\n    @param addr The address being added to the whitelist\n    */\n    event ScopeWhitelistAdd(string scopeName, address indexed actor, address indexed addr);\n\n    /**\n    @notice Emitted when a scope has an address removed from the whitelist\n    @param scopeName The name of the scope\n    @param actor The address responsible for the action\n    @param addr The address being removed from the whitelist\n    */\n    event ScopeWhitelistRemove(string scopeName, address indexed actor, address indexed addr);\n\n    /**\n    @notice Emitted when a mint is configured\n    @param scopeName The name of the scope\n    @param mintable The address of the IPatchworkMintable\n    @param config The mint configuration\n    */\n    event MintConfigure(string scopeName, address indexed actor, address indexed mintable, MintConfig config);\n\n    /**\n    @notice Emitted when a banker is added to a scope\n    @param scopeName The name of the scope\n    @param actor The address responsible for the action\n    @param banker The banker that was added\n    */\n    event ScopeBankerAdd(string scopeName, address indexed actor, address indexed banker);\n\n    /**\n    @notice Emitted when a banker is removed from a scope\n    @param scopeName The name of the scope\n    @param actor The address responsible for the action\n    @param banker The banker that was removed\n    */\n    event ScopeBankerRemove(string scopeName, address indexed actor, address indexed banker);\n    \n    /**\n    @notice Emitted when a withdrawl is made from a scope\n    @param scopeName The name of the scope\n    @param actor The address responsible for the action\n    @param amount The amount withdrawn\n    */    \n    event ScopeWithdraw(string scopeName, address indexed actor, uint256 amount);\n\n    /**\n    @notice Emitted when a banker is added to the protocol\n    @param actor The address responsible for the action\n    @param banker The banker that was added\n    */\n    event ProtocolBankerAdd(address indexed actor, address indexed banker);\n\n    /**\n    @notice Emitted when a banker is removed from the protocol\n    @param actor The address responsible for the action\n    @param banker The banker that was removed\n    */\n    event ProtocolBankerRemove(address indexed actor, address indexed banker);\n\n    /**\n    @notice Emitted when a withdrawl is made from the protocol\n    @param actor The address responsible for the action\n    @param amount The amount withdrawn\n    */\n    event ProtocolWithdraw(address indexed actor, uint256 amount);\n\n    /**\n    @notice Emitted on mint\n    @param actor The address responsible for the action\n    @param scopeName The scope of the IPatchworkMintable\n    @param to The receipient of the mint\n    @param mintable The IPatchworkMintable minted\n    @param data The data used to mint\n    */\n    event Mint(address indexed actor, string scopeName, address indexed to, address indexed mintable, bytes data);\n\n    /**\n    @notice Emitted on batch mint\n    @param actor The address responsible for the action\n    @param scopeName The scope of the IPatchworkMintable\n    @param to The receipient of the mint\n    @param mintable The IPatchworkMintable minted\n    @param data The data used to mint\n    @param quantity The quantity minted\n    */\n    event MintBatch(address indexed actor, string scopeName, address indexed to, address indexed mintable, bytes data, uint256 quantity);\n\n    /**\n    @notice Emitted on protocol fee config proposed\n    */\n    event ProtocolFeeConfigPropose(FeeConfig config);\n\n    /**\n    @notice Emitted on protocol fee config committed\n    */\n    event ProtocolFeeConfigCommit(FeeConfig config);\n\n    /**\n    @notice Emitted on scope fee config override proposed\n    */\n    event ScopeFeeOverridePropose(string scopeName, FeeConfigOverride config);\n\n    /**\n    @notice Emitted on scope fee config override committed\n    */\n    event ScopeFeeOverrideCommit(string scopeName, FeeConfigOverride config);\n\n    /**\n    @notice Emitted on patch fee change \n    */\n    event PatchFeeChange(string scopeName, address indexed addr, uint256 fee);\n\n    /**\n    @notice Emitted on assign fee change \n    */\n    event AssignFeeChange(string scopeName, address indexed addr, uint256 fee);\n\n    /**\n    @notice Claim a scope\n    @param scopeName the name of the scope\n    */\n    function claimScope(string calldata scopeName) external;\n\n    /**\n    @notice Transfer ownership of a scope\n    @dev must be accepted by transferee - see {acceptScopeTransfer}\n    @param scopeName Name of the scope\n    @param newOwner Address of the new owner\n    */\n    function transferScopeOwnership(string calldata scopeName, address newOwner) external;\n\n    /**\n    @notice Cancel a pending scope transfer\n    @param scopeName Name of the scope\n    */\n    function cancelScopeTransfer(string calldata scopeName) external;\n\n    /**\n    @notice Accept a scope transfer\n    @param scopeName Name of the scope\n    */\n    function acceptScopeTransfer(string calldata scopeName) external;\n\n    /**\n    @notice Get owner-elect of a scope\n    @param scopeName Name of the scope\n    @return ownerElect Address of the scope's owner-elect\n    */\n    function getScopeOwnerElect(string calldata scopeName) external view returns (address ownerElect);\n\n    /**\n    @notice Get owner of a scope\n    @param scopeName Name of the scope\n    @return owner Address of the scope owner\n    */\n    function getScopeOwner(string calldata scopeName) external view returns (address owner);\n\n    /**\n    @notice Add an operator to a scope\n    @param scopeName Name of the scope\n    @param op Address of the operator\n    */\n    function addOperator(string calldata scopeName, address op) external;\n\n    /**\n    @notice Remove an operator from a scope\n    @param scopeName Name of the scope\n    @param op Address of the operator\n    */\n    function removeOperator(string calldata scopeName, address op) external;\n\n    /**\n    @notice Set rules for a scope\n    @param scopeName Name of the scope\n    @param allowUserPatch Boolean indicating whether user patches are allowed\n    @param allowUserAssign Boolean indicating whether user assignments are allowed\n    @param requireWhitelist Boolean indicating whether whitelist is required\n    */\n    function setScopeRules(string calldata scopeName, bool allowUserPatch, bool allowUserAssign, bool requireWhitelist) external;\n\n    /**\n    @notice Add an address to a scope's whitelist\n    @param scopeName Name of the scope\n    @param addr Address to be whitelisted\n    */\n    function addWhitelist(string calldata scopeName, address addr) external;\n\n    /**\n    @notice Remove an address from a scope's whitelist\n    @param scopeName Name of the scope\n    @param addr Address to be removed from the whitelist\n    */\n    function removeWhitelist(string calldata scopeName, address addr) external;\n\n    /**\n    @notice Set the mint configuration for a given address\n    @param addr The address for which to set the mint configuration, must be IPatchworkMintable\n    @param config The mint configuration to be set\n    */\n    function setMintConfiguration(address addr, MintConfig memory config) external;\n\n    /**\n    @notice Get the mint configuration for a given address\n    @param addr The address for which to get the mint configuration\n    @return config The mint configuration of the given address\n    */\n    function getMintConfiguration(address addr) external view returns (MintConfig memory config);\n\n    /**\n    @notice Set the patch fee for a given address\n    @dev must be banker of scope claimed by addr to call\n    @param addr The address for which to set the patch fee\n    @param baseFee The patch fee to be set in wei\n    */\n    function setPatchFee(address addr, uint256 baseFee) external;\n\n    /**\n    @notice Get the patch fee for a given address\n    @param addr The address for which to get the patch fee\n    @return baseFee The patch fee of the given address in wei\n    */\n    function getPatchFee(address addr) external view returns (uint256 baseFee);\n\n    /**\n    @notice Set the assign fee for a given fragment address\n    @dev must be banker of scope claimed by fragmentAddress to call\n    @param fragmentAddress The address of the fragment for which to set the fee\n    @param baseFee The assign fee to be set in wei\n    */\n    function setAssignFee(address fragmentAddress, uint256 baseFee) external;\n\n    /**\n    @notice Get the assign fee for a given fragment address\n    @param fragmentAddress The address of the fragment for which to get the fee\n    @return baseFee The assign fee of the given fragment address in wei\n    */\n    function getAssignFee(address fragmentAddress) external view returns (uint256 baseFee);\n\n    /**\n    @notice Add a banker to a given scope\n    @dev must be owner of scope to call\n    @param scopeName The name of the scope\n    @param addr The address to be added as a banker\n    */\n    function addBanker(string memory scopeName, address addr) external;\n\n    /**\n    @notice Remove a banker from a given scope\n    @dev must be owner of scope to call\n    @param scopeName The name of the scope\n    @param addr The address to be removed as a banker\n    */\n    function removeBanker(string memory scopeName, address addr) external;\n\n    /**\n    @notice Withdraw an amount from the balance of a given scope\n    @dev must be owner of scope or banker of scope to call\n    @dev transfers to the msg.sender\n    @param scopeName The name of the scope\n    @param amount The amount to be withdrawn in wei\n    */\n    function withdraw(string memory scopeName, uint256 amount) external;\n\n    /**\n    @notice Get the balance of a given scope\n    @param scopeName The name of the scope\n    @return balance The balance of the given scope in wei\n    */\n    function balanceOf(string memory scopeName) external view returns (uint256 balance);\n\n    /**\n    @notice Mint a new token\n    @param to The address to which the token will be minted\n    @param mintable The address of the IPatchworkMintable contract\n    @param data Additional data to be passed to the minting\n    @return tokenId The ID of the minted token\n    */\n    function mint(address to, address mintable, bytes calldata data) external payable returns (uint256 tokenId);\n\n    /**\n    @notice Mint a batch of new tokens\n    @param to The address to which the tokens will be minted\n    @param mintable The address of the IPatchworkMintable contract\n    @param data Additional data to be passed to the minting\n    @param quantity The number of tokens to mint\n    @return tokenIds An array of the IDs of the minted tokens\n    */\n    function mintBatch(address to, address mintable, bytes calldata data, uint256 quantity) external payable returns (uint256[] memory tokenIds);\n\n    /**\n    @notice Proposes a protocol fee configuration\n    @dev must be protocol owner or banker to call\n    @dev configuration does not apply until commitProtocolFeeConfig is called\n    @param config The protocol fee configuration to be set\n    */\n    function proposeProtocolFeeConfig(FeeConfig memory config) external;\n\n    /**\n    @notice Commits the current proposed protocol fee configuration\n    @dev must be protocol owner or banker to call\n    @dev may only be called after timelock has passed\n    */\n    function commitProtocolFeeConfig() external;\n\n    /**\n    @notice Get the current protocol fee configuration\n    @return config The current protocol fee configuration\n    */\n    function getProtocolFeeConfig() external view returns (FeeConfig memory config);\n\n    /**\n    @notice Proposes a protocol fee override for a scope\n    @dev must be protocol owner or banker to call\n    @param config The protocol fee override configuration to be set\n    */\n    function proposeScopeFeeOverride(string memory scopeName, FeeConfigOverride memory config) external;\n\n    /**\n    @notice Commits the current proposed protocol fee override configuration for a scope\n    @dev must be protocol owner or banker to call\n    @dev may only be called after timelock has passed\n    */\n    function commitScopeFeeOverride(string memory scopeName) external;\n\n    /**\n    @notice Get the protocol fee override for a scope\n    @return config The current protocol fee override\n    */\n    function getScopeFeeOverride(string memory scopeName) external view returns (FeeConfigOverride memory config);\n\n    /**\n    @notice Add a banker to the protocol\n    @dev must be protocol owner to call\n    @param addr The address to be added as a protocol banker\n    */\n    function addProtocolBanker(address addr) external;\n\n    /**\n    @notice Remove a banker from the protocol\n    @dev must be protocol owner to call\n    @param addr The address to be removed as a protocol banker\n    */\n    function removeProtocolBanker(address addr) external;\n\n    /**\n    @notice Withdraw a specified amount from the protocol balance\n    @dev must be protocol owner or banker to call\n    @dev transfers to the msg.sender\n    @param balance The amount to be withdrawn in wei\n    */\n    function withdrawFromProtocol(uint256 balance) external;\n\n    /**\n    @notice Get the current balance of the protocol\n    @return balance The balance of the protocol in wei\n    */\n    function balanceOfProtocol() external view returns (uint256 balance);\n\n    /**\n    @notice Create a new patch\n    @param owner The owner of the patch\n    @param originalAddress Address of the original 721\n    @param originalTokenId Token ID of the original 721\n    @param patchAddress Address of the IPatchworkPatch to mint\n    @return tokenId Token ID of the newly created patch\n    */\n    function patch(address owner, address originalAddress, uint originalTokenId, address patchAddress) external payable returns (uint256 tokenId);\n\n    /**\n    @notice Callback for when a patch is burned\n    @dev can only be called from the patchAddress\n    @param originalAddress Address of the original 721\n    @param originalTokenId Token ID of the original 721\n    @param patchAddress Address of the IPatchworkPatch to mint\n    */\n    function patchBurned(address originalAddress, uint originalTokenId, address patchAddress) external;\n\n    /**\n    @notice Create a new 1155 patch\n    @param originalAddress Address of the original 1155\n    @param originalTokenId Token ID of the original 1155\n    @param originalAccount Address of the account to patch\n    @param patchAddress Address of the IPatchworkPatch to mint\n    @return tokenId Token ID of the newly created patch\n    */\n    function patch1155(address to, address originalAddress, uint originalTokenId, address originalAccount, address patchAddress) external payable returns (uint256 tokenId);\n    \n    /**\n    @notice Callback for when an 1155 patch is burned\n    @dev can only be called from the patchAddress\n    @param originalAddress Address of the original 1155\n    @param originalTokenId Token ID of the original 1155\n    @param originalAccount Address of the account to patch\n    @param patchAddress Address of the IPatchworkPatch to mint\n    */\n    function patchBurned1155(address originalAddress, uint originalTokenId, address originalAccount, address patchAddress) external;\n\n    /**\n    @notice Create a new account patch\n    @param owner The owner of the patch\n    @param originalAddress Address of the original account\n    @param patchAddress Address of the IPatchworkPatch to mint\n    @return tokenId Token ID of the newly created patch\n    */\n    function patchAccount(address owner, address originalAddress, address patchAddress) external payable returns (uint256 tokenId);\n\n    /**\n    @notice Callback for when an account patch is burned\n    @dev can only be called from the patchAddress\n    @param originalAddress Address of the original 1155\n    @param patchAddress Address of the IPatchworkPatch to mint\n    */\n    function patchBurnedAccount(address originalAddress, address patchAddress) external;\n\n    /**\n    @notice Assigns a relation to have an IPatchworkLiteRef form a LiteRef to a IPatchworkAssignable\n    @param fragment The IPatchworkAssignable address to assign\n    @param fragmentTokenId The IPatchworkAssignable Token ID to assign\n    @param target The IPatchworkLiteRef address to hold the reference to the fragment\n    @param targetTokenId The IPatchworkLiteRef Token ID to hold the reference to the fragment\n    */\n    function assign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId) external payable;\n\n    /**\n    @notice Assigns a relation to have an IPatchworkLiteRef form a LiteRef to a IPatchworkAssignable\n    @param fragment The IPatchworkAssignable address to assign\n    @param fragmentTokenId The IPatchworkAssignable Token ID to assign\n    @param target The IPatchworkLiteRef address to hold the reference to the fragment\n    @param targetTokenId The IPatchworkLiteRef Token ID to hold the reference to the fragment\n    @param targetMetadataId The metadata ID on the target to store the reference in\n    */\n    function assign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, uint256 targetMetadataId) external payable;\n\n    /**\n    @notice Assign multiple fragments to a target in batch\n    @param fragments The array of addresses of the fragment IPatchworkAssignables\n    @param tokenIds The array of token IDs of the fragment IPatchworkAssignables\n    @param target The address of the target IPatchworkLiteRef \n    @param targetTokenId The token ID of the target IPatchworkLiteRef \n    */\n    function assignBatch(address[] calldata fragments, uint[] calldata tokenIds, address target, uint targetTokenId) external payable;\n\n    /**\n    @notice Assign multiple fragments to a target in batch\n    @param fragments The array of addresses of the fragment IPatchworkAssignables\n    @param tokenIds The array of token IDs of the fragment IPatchworkAssignables\n    @param target The address of the target IPatchworkLiteRef \n    @param targetTokenId The token ID of the target IPatchworkLiteRef \n    @param targetMetadataId The metadata ID on the target to store the references in\n    */\n    function assignBatch(address[] calldata fragments, uint[] calldata tokenIds, address target, uint targetTokenId, uint256 targetMetadataId) external payable;\n\n    /**\n    @notice Unassign a fragment from a target\n    @param fragment The IPatchworkSingleAssignable address of the fragment\n    @param fragmentTokenId The IPatchworkSingleAssignable token ID of the fragment\n    @dev reverts if fragment is not an IPatchworkSingleAssignable\n    */\n    function unassignSingle(address fragment, uint fragmentTokenId) external;\n    \n    /**\n    @notice Unassign a fragment from a target\n    @param fragment The IPatchworkSingleAssignable address of the fragment\n    @param fragmentTokenId The IPatchworkSingleAssignable token ID of the fragment\n    @param targetMetadataId The metadata ID on the target to unassign from\n    @dev reverts if fragment is not an IPatchworkSingleAssignable\n    */\n    function unassignSingle(address fragment, uint fragmentTokenId, uint256 targetMetadataId) external;\n\n    /**\n    @notice Unassigns a multi relation\n    @param fragment The IPatchworMultiAssignable address to unassign\n    @param fragmentTokenId The IPatchworkMultiAssignable Token ID to unassign\n    @param target The IPatchworkLiteRef address which holds a reference to the fragment\n    @param targetTokenId The IPatchworkLiteRef Token ID which holds a reference to the fragment\n    @dev reverts if fragment is not an IPatchworkMultiAssignable\n    */\n    function unassignMulti(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId) external;\n\n    /**\n    @notice Unassigns a multi relation\n    @param fragment The IPatchworMultiAssignable address to unassign\n    @param fragmentTokenId The IPatchworkMultiAssignable Token ID to unassign\n    @param target The IPatchworkLiteRef address which holds a reference to the fragment\n    @param targetTokenId The IPatchworkLiteRef Token ID which holds a reference to the fragment\n    @param targetMetadataId The metadata ID on the target to unassign from\n    @dev reverts if fragment is not an IPatchworkMultiAssignable\n    */\n    function unassignMulti(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, uint256 targetMetadataId) external;\n\n    /**\n    @notice Unassigns a relation (single or multi)\n    @param fragment The IPatchworkAssignable address to unassign\n    @param fragmentTokenId The IPatchworkAssignable Token ID to unassign\n    @param target The IPatchworkLiteRef address which holds a reference to the fragment\n    @param targetTokenId The IPatchworkLiteRef Token ID which holds a reference to the fragment\n    */\n    function unassign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId) external;\n\n    /**\n    @notice Unassigns a relation (single or multi)\n    @param fragment The IPatchworkAssignable address to unassign\n    @param fragmentTokenId The IPatchworkAssignable Token ID to unassign\n    @param target The IPatchworkLiteRef address which holds a reference to the fragment\n    @param targetTokenId The IPatchworkLiteRef Token ID which holds a reference to the fragment\n    @param targetMetadataId The metadata ID on the target to unassign from\n    */\n    function unassign(address fragment, uint256 fragmentTokenId, address target, uint256 targetTokenId, uint256 targetMetadataId) external;\n\n    /**\n    @notice Apply transfer rules and actions of a specific token from one address to another\n    @param from The address of the sender\n    @param to The address of the receiver\n    @param tokenId The ID of the token to be transferred\n    */\n    function applyTransfer(address from, address to, uint256 tokenId) external;\n\n    /**\n    @notice Update the ownership tree of a specific Patchwork 721\n    @param addr The address of the Patchwork 721\n    @param tokenId The ID of the token whose ownership tree needs to be updated\n    */\n    function updateOwnershipTree(address addr, uint256 tokenId) external;\n}"},"src/interfaces/IPatchworkMintable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IPatchworkScoped.sol\";\n\n/**\n@title Patchwork Mintable Interface\n@author Runic Labs, Inc\n*/\ninterface IPatchworkMintable is IPatchworkScoped {\n\n    /**\n    @notice Mint a new token\n    @dev Mints a single token to a specified address.\n    @param to The address to which the token will be minted.\n    @param data Additional data to be passed to the minting process.\n    @return tokenId The ID of the minted token.\n    */\n    function mint(address to, bytes calldata data) external payable returns (uint256 tokenId);\n    \n    /**\n    @notice Mint a batch of new tokens\n    @dev Mints multiple tokens to a specified address.\n    @param to The address to which the tokens will be minted.\n    @param data Additional data to be passed to the minting process.\n    @param quantity The number of tokens to mint.\n    @return tokenIds An array of the IDs of the minted tokens.\n    */\n    function mintBatch(address to, bytes calldata data, uint256 quantity) external payable returns (uint256[] memory tokenIds);\n}"},"src/interfaces/IPatchworkScoped.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n@title Patchwork Protocol Scoped Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting scopes\n*/\ninterface IPatchworkScoped {\n    /**\n    @notice Get the scope this NFT claims to belong to\n    @return string the name of the scope\n    */\n    function getScopeName() external view returns (string memory);\n}"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"src/interfaces/IERC5192.sol":{"content":"// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\ninterface IERC5192 {\n  /// @notice Emitted when the locking status is changed to locked.\n  /// @dev If a token is minted and the status is locked, this event should be emitted.\n  /// @param tokenId The identifier for a token.\n  event Locked(uint256 indexed tokenId);\n\n  /// @notice Emitted when the locking status is changed to unlocked.\n  /// @dev If a token is minted and the status is unlocked, this event should be emitted.\n  /// @param tokenId The identifier for a token.\n  event Unlocked(uint256 indexed tokenId);\n\n  /// @notice Returns the locking status of an Soulbound Token\n  /// @dev SBTs assigned to zero address are considered invalid, and queries\n  /// about them do throw.\n  /// @param tokenId The identifier for an SBT.\n  function locked(uint256 tokenId) external view returns (bool);\n}"},"src/interfaces/IPatchworkAssignable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IPatchworkScoped.sol\";\n\n/**\n@title Patchwork Protocol Assignable NFT Interface\n@author Runic Labs, Inc\n@notice Interface for contracts supporting Patchwork assignment\n*/\ninterface IPatchworkAssignable is IPatchworkScoped {\n    \n    /// Represents an assignment of a token from an external NFT contract to a token in this contract.\n    struct Assignment {\n        address tokenAddr;  /// The address of the external NFT contract.\n        uint256 tokenId;    /// The ID of the token in the external NFT contract.\n    }\n\n    /**\n    @notice Assigns a token to another\n    @param ourTokenId ID of our token\n    @param to Address to assign to\n    @param tokenId ID of the token to assign\n    */\n    function assign(uint256 ourTokenId, address to, uint256 tokenId) external;\n\n    /**\n    @notice Checks permissions for assignment\n    @param ourTokenId the tokenID to assign\n    @param target the address of the target\n    @param targetTokenId the tokenID of the target\n    @param targetOwner the ownerOf of the target\n    @param by the account invoking the assignment to Patchwork Protocol\n    @param scopeName the scope name of the contract to assign to\n    */\n    function allowAssignment(uint256 ourTokenId, address target, uint256 targetTokenId, address targetOwner, address by, string memory scopeName) external view returns (bool);\n}"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@patchwork/=src/","forge-std/=lib/forge-std/src/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/","solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/"],"optimizer":{"enabled":true,"runs":200},"viaIR":true,"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","libraries":{}}}
